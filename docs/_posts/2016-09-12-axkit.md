---
layout: post
title:  iOS链式封装，更优雅地存取沙盒文件
date:   2016-09-12
categories: axkit
tag:
- iOS
- AXKit
- 缓存
- 沙盒文件

---



> 关于iOS的沙盒机制，不是本文的重点内容。如果没有基础，可以先看一下这篇博客：[@cnblogs](http://www.cnblogs.com/yswdarren/p/3554442.html)
>
> 虽然沙盒缓存相对SQLite来说有很多劣势，但是对于一些轻量级读写不频繁的情况下，使用沙盒缓存要方便很多。


## 使用场景

假如你有一个类要做沙盒缓存，您准备怎么做？

看完本篇博客，你只需要一行代码：

```objective-c
@"文件名".cachePath.save(实例);
```

如果对这种实现感兴趣，请看下面详细内容。


## 导入AXKit

**推荐CocoaPods方式，也可以下载[【源码】](https://github.com/xaoxuu/AXKit)手动导入**

```ruby
pod 'AXKit'
```

**AXKit头文件**

```objective-c
// CocoaPods方式
#import <AXKit/AXKit.h>
// 手动方式
#import "AXKit.h"
```




## 接口功能详解

### 存取自定义的类

需要实现NSCoding协议

```objective-c
// 存取自定义类
MyProfiles *myfile = [[MyProfiles alloc] init];
// 在cache路径下归档一个名为"myfile.plist"的文件，文件需实现NSCoding协议
BOOL result = @"myfile".cachePath.saveArchivedPlist(myfile);
// 在cache路径下读取一个名为"vc.plist"的已归档的文件
MyProfiles *read = @"myfile".cachePath.readArchivedPlist;
```



### 存取数组、字典、文本

存取苹果官方的类不需要实现NSCoding协议，但是得指定格式
（如果使用readArray、readDictionary等这些相当于已经指定了格式了）

```objective-c
// 存取数组(或字典)
// 在doc路径下保存一个名为"arr.plist"的文件
NSArray *arr = [NSArray array];
BOOL result = @"arr".docPath.savePlist(arr);
NSArray *read = @"arr".docPath.readArray;
// 存取可变数组(或可变字典)
NSMutableArray *mArr = [NSMutableArray array];
result = @"mArr".docPath.savePlist(mArr);
NSMutableArray *readM = @"mArr".docPath.readArray;
```

存取字符串文本

```objective-c
// 存取文本
NSString *str = @"这是需要保存的文本内容";
BOOL result = @"text".txt.save(str);
NSString *readStr = @"text".readTxt;
// 或NSString *readStr = @"text".txt.readTxt; 请放心使用，不会重复添加相同的后缀名
```



### 遍历路径下所有文件

```objective-c
// 获取doc/myDir 路径下所有的扩展名为"plist"文件路径
NSArray *paths = @"myDir".docPath.subpaths(@"plist");
// 如果传入值为空，则不区分扩展名获取所有文件路径
NSArray *paths2 = @"myDir".docPath.subpaths(@"");
// paths里面装的是doc/myDir路径下的所有文件完整路径
```



### 自定义

如果上面的常用功能不能满足需求，可以一步一步来

##### 拼接路径是这样的：

```objective-c
// 首先确定文件名是"abc"
NSString *path = @"abc";        // path = @"abc"
// 指定扩展名，这一步有点鸡肋，你也可以直接在第一步里确定
NSString *path2 = path.txt; // plistPath = @"abc.txt"
// 确定文件在哪里,doc/cache/tmp等等
NSString *path3 = path2.docPath;
// path3 = @"~/documents/abc.txt" (沙盒路径的documents目录)
// NSString *path100 = path.path(NSSearchPathDirectory); 传入NSSearchPathDirectory
```

使用“.path(NSSearchPathDirectory)”传入枚举可以进入到NSSearchPath枚举的路径。

##### 还可以拼接到mainBundle

```objective-c
// 如果你有一张图片在bundle里
NSString *imageName = @"image";
NSString *imagePath = imageName.mainBundlePath;
UIImage *image = [UIImage imageWithContentsOfFile:image];
// 如果你有一组(例如10张)图片在bundle里，名分别为image0,image1,image2,...,image9
NSArray<UIImage *> *images = [UIImage ax_imageWithBundleImageName:image count:10];
```

##### 拼接扩展名也很简单

```objective-c
// .plist
// .json
// .txt
// 或其他的后缀名
NSString *filePath = path.extension(@"exe");
// otherPath = @"abc.exe"
// 读取的时候，需要指定扩展名
id readFile = filePath.extension(@"exe").readArchivedFile;
```

##### 读取文件的方法

- 读取一个数组或可变数组(自动追加.plist)

  ```objective-c
  - (nullable __kindof NSArray *)readArray;
  ```

- 读取一个字典或可变字典(自动追加.plist)

  ```objective-c
  - (nullable __kindof NSDictionary *)readDictionary;
  ```

- 解档一个已归档的plist文件(自动追加.plist)

  ```objective-c
  - (nullable id)readArchivedPlist;
  ```

- 读取一个json文件(返回一个数组或字典)(自动追加.json)

  如果有一个格式正常的json，可以直接调用"readJson"读取成字典或者数组

  ```objective-c
  - (nullable id)readJson;
  ```

- 读取一个纯文本文件(自动追加.txt)

  ```objective-c
  - (nullable NSString *)readTxt;
  ```

- 解档一个已归档的文件

  ```objective-c
  - (nullable id)readArchivedFile;
  ```




##### 写入文件的方法

- 保存一个plist文件（自动追加.plist）

  ```objective-c
  - (BOOL(^)(id))savePlist;
  ```

- 归档一个实现NSCoding协议的plist文件（自动追加.plist）

  ```objective-c
  - (BOOL(^)(NSObject<NSCoding> *))saveArchivedPlist;
  ```

- 归档一个文件

  ```objective-c
  - (BOOL(^)(id <NSCoding>))save;
  ```


其中“savePlist()”和“saveArchivedPlist()”会自动追加“.plist”扩展名，

而"save()"不会自动追加扩展名，使用这个方法要注意添加扩展名。



##### 删除文件的方法

- 删除一个plist文件（自动追加.plist）

  ```objective-c
  - (BOOL)removePlist;
  ```

- 删除一个json文件（自动追加.json）

  ```objective-c
  - (BOOL)removeJson;
  ```

- 删除一个txt文件（自动追加.txt）

  ```objective-c
  - (BOOL)removeTxt;
  ```
- 删除一个文件

  ```objective-c
  - (BOOL)remove;
  ```


和保存一样，最后一个方法是不自动追加扩展名的，需要传入一个扩展名
